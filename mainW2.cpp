/*  В текстовом файле с именем FN1 дано арифметическое выражение в инфиксной форме.
    В выражении могут использоваться операции: сложение(+), вычитание(-), умножение(*), деление нацело(/), остаток от деления(%), возведение в степень(^), а так же целые числа из промежутка [1; 30] и переменная x. 
    Для операции возведения в степень показатель степени неотрицательное целое число. Постройте дерево выражения. После этого вычислите значение выражения при заданном значении переменной x и выведите результат в текстовый файл с именем FN2.
    Преобразуйте дерево, заменив все поддеревья вида A+x на x+A, где A - некоторое поддерево, а x - переменная. 
    Распечатайте дерево после преобразования в файл FN2 в префиксной и постфиксной форме, а так же в инфиксной форме с избыточными скобками. 
    При наличии нескольких подряд идущих одинаковых операций дерево должно строиться по правилу: операции одинакового приоритета вычисляются по порядку слева направо. 
    Иными словами, выражение 2+3+4+5, например, должно трактоваться как ((2+3)+4)+5, и не может трактоваться как (2+3)+(4+5) или 2+(3+(4+5)). 
    Результаты всех вычислений, включая промежуточные, принадлежат типу int. 
 */

#include "expression_w.h"

int mainW2() {
    try {
        string input_file = "FN1.txt";
        string output_file = "FN2.txt";

        string expression = ReadExpressionFromFile(input_file);
        ExpressionTree tree = ExpressionTree::BuildFromInfix(expression);

        int x_value;
        cout << "Введите значение x: "; 
        cin >> x_value;

        int result = tree.Evaluate(x_value);
        WriteResultToFile(output_file, result, tree);

        cout << "Результат записан в файл " << output_file << endl;
    } catch (const exception& e) {
        cerr << "Ошибка: " << e.what() << endl;
        return 1;
    }

    return 0;
}
